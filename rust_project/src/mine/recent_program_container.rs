use std::error::Error;
use std::fmt;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::Path;
use serde::Deserialize;
use rand::Rng;
use rand::seq::SliceRandom;

// Divide up the programs into equal sized clusters with similar age.
const NUMBER_OF_CLUSTERS: u8 = 10;


// Some programs are newer than older programs.
//
// This is a data structure for picking a recently added program.
//
// Without this data structure, it would be terrible time consuming
// making a weighted choice among the programs.
//
// Inside the file `program_creation_dates.csv`:
// The column `creation date` contain a date with the format yyyymmdd.
// Example: "19841230" is a program created on: 1984 dec 30.
// This may be old or new, depending on what other dates are present in this csv file.
//
// A new program that have just been added to the repository,
// may be useful or not useful. The goal with this `RecentProgramContainer`
// is to exercise the most recent programs.
// The recent programs are assigned `cluster_id` 9.
//
// The oldest program that have been in the repository for years,
// these programs are assigned `cluster_id` 0.
//
// Programs with an age in between the oldest and the newest,
// These programs are assigned `cluster_id` 1..8.
//
// On initialization the `program_creation_dates.csv` is loaded.
// This CSV file have been generated by using `git log` for 
// extracting the creation date.
pub struct RecentProgramContainer {
    cluster_program_ids: Vec<Vec<u32>>,
}

impl RecentProgramContainer {
    pub fn load(path: &Path) -> Result<Self, Box<dyn Error>> {
        let file = File::open(path)?;
        let mut reader = BufReader::new(file);
        process_csv_into_clusters(&mut reader)
    }

    #[allow(dead_code)]
    fn cluster_program_ids(&self) -> &Vec<Vec<u32>> {
        &self.cluster_program_ids
    }

    #[allow(dead_code)]
    pub fn choose<R: Rng + ?Sized>(&self, rng: &mut R) -> Option<u32> {
        let cluster_weight_vec: Vec<(usize,usize)> = vec![
            (0, 1), // Low probability for choosing an old program.
            (1, 2),
            (2, 4),
            (3, 8),
            (4, 16),
            (5, 32),
            (6, 64),
            (7, 128),
            (8, 256),
            (9, 512), // High probablility for choosing a recent program.
        ];
        assert!(cluster_weight_vec.len() == (NUMBER_OF_CLUSTERS as usize));
        let cluster_id: &usize = &cluster_weight_vec.choose_weighted(rng, |item| item.1).unwrap().0;
        let program_ids: &Vec<u32> = &self.cluster_program_ids[*cluster_id];
        if program_ids.is_empty() {
            // The CSV file is supposed to have hundreds of rows, so there
            // should be several program_ids for every cluster_id.
            // No matter what cluster_id is picked, there should be at least 1 program.
            // Return None, in the unfortunate case there isn't any program_ids for the picked cluser_id.
            return None;
        }
        let program_id: u32 = match program_ids.choose(rng) {
            Some(program_id) => *program_id,
            None => {
                // For a non-empty vector, this shouldn't happen.
                return None;
            }
        };
        Some(program_id)
    }
}

fn process_csv_into_clusters(reader: &mut dyn BufRead) -> Result<RecentProgramContainer, Box<dyn Error>> {
    let records: Vec<Record> = process_csv_data(reader)?;
    convert_records_to_clusters(records)
}

#[derive(Debug, Deserialize)]
struct Record {
    #[serde(rename = "program id")]
    program_id: u32,

    #[serde(rename = "creation date")]
    creation_date: u32, // format like this: yyyymmdd, eg. 19841230
}

impl Record {
    #[cfg(test)]
    fn new(program_id: u32, creation_date: u32) -> Self {
        Self {
            program_id: program_id,
            creation_date: creation_date,
        }
    }
}

fn process_csv_data(reader: &mut dyn BufRead) -> Result<Vec<Record>, Box<dyn Error>> {
    let mut records = Vec::<Record>::new();
    let mut csv_reader = csv::ReaderBuilder::new()
        .delimiter(b';')
        .from_reader(reader);
    for result in csv_reader.deserialize() {
        let record: Record = result?;
        records.push(record);
    }
    Ok(records)
}

fn chunk_size(item_count: usize, chunk_count: usize) -> usize {
    (item_count + chunk_count - 1) / chunk_count
}

fn convert_records_to_clusters(mut records: Vec<Record>) -> Result<RecentProgramContainer, Box<dyn Error>> {
    // Order program_ids by their creation date
    records.sort_by(|a,b| a.creation_date.cmp(&b.creation_date));

    let count: usize = records.len();
    let cluster_len: usize = count / (NUMBER_OF_CLUSTERS as usize);

    // Identify program_ids for each cluster
    let mut clusters: Vec<Vec<u32>> = vec!();
    if cluster_len >= 1 {
        for records_in_chunk in records.chunks(cluster_len) {
            let mut program_ids: Vec<u32> = vec!();
            for record in records_in_chunk {
                program_ids.push(record.program_id);
            }
            clusters.push(program_ids);
        }
    }

    // Padding if needed
    let padding: usize = (NUMBER_OF_CLUSTERS as usize) - clusters.len();
    for _ in 0..padding {
        let program_ids: Vec<u32> = vec!();
        clusters.push(program_ids);
    }

    let container = RecentProgramContainer {
        cluster_program_ids: clusters
    };
    Ok(container)
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_10000_process_csv_data() {
        let data = "\
program id;creation date
4;20190115
5;20190119

6;20210316
7;20181012
";
        let mut input: &[u8] = data.as_bytes();
        let records: Vec<Record> = process_csv_data(&mut input).unwrap();
        let strings: Vec<String> = records.iter().map(|record| {
            format!("{} {}", record.program_id, record.creation_date)
        }).collect();
        let strings_joined: String = strings.join(",");
        assert_eq!(strings_joined, "4 20190115,5 20190119,6 20210316,7 20181012");
    }

    #[test]
    fn test_10002_convert_records_to_clusters_success() {
        let records: Vec<Record> = vec![
            Record::new(101, 19840101),
            Record::new(102, 19840102),
            Record::new(103, 19840103),
            Record::new(104, 19840104),
            Record::new(105, 19840105),
            Record::new(106, 19840106),
            Record::new(107, 19840107),
            Record::new(108, 19840108),
            Record::new(109, 19840109),
            Record::new(110, 19840110),
        ];
        let container: RecentProgramContainer = convert_records_to_clusters(records).unwrap();
        let cluster_program_ids: &Vec<Vec<u32>> = container.cluster_program_ids();
        assert_eq!(cluster_program_ids.len(), 10);
        assert_eq!(cluster_program_ids[0].len(), 1);
        assert_eq!(cluster_program_ids[4].len(), 1);
        assert_eq!(cluster_program_ids[9].len(), 1);
    }

    #[test]
    fn test_10003_chunk_size() {
        assert_eq!(chunk_size(1, 1), 1);

        assert_eq!(chunk_size(4, 1), 4);
        assert_eq!(chunk_size(4, 2), 2);
        assert_eq!(chunk_size(4, 3), 2);
        assert_eq!(chunk_size(4, 4), 1);
        assert_eq!(chunk_size(4, 5), 1);
        assert_eq!(chunk_size(4, 100), 1);

        assert_eq!(chunk_size(5, 1), 5);
        assert_eq!(chunk_size(5, 2), 3);
        assert_eq!(chunk_size(5, 3), 2);
        assert_eq!(chunk_size(5, 4), 2);
        assert_eq!(chunk_size(5, 5), 1);
        assert_eq!(chunk_size(5, 6), 1);
        assert_eq!(chunk_size(5, 7), 1);
        assert_eq!(chunk_size(5, 8), 1);

        assert_eq!(chunk_size(6, 1), 6);
        assert_eq!(chunk_size(6, 2), 3);
        assert_eq!(chunk_size(6, 3), 2);
        assert_eq!(chunk_size(6, 4), 2);
        assert_eq!(chunk_size(6, 5), 2);
        assert_eq!(chunk_size(6, 6), 1);
        assert_eq!(chunk_size(6, 7), 1);

        assert_eq!(chunk_size(999, 10), 100);
        assert_eq!(chunk_size(1000, 10), 100);
        assert_eq!(chunk_size(1001, 10), 101);
    }
}
