<!doctype html><html lang="en"><head><meta charset="utf-8">
<meta name="robots" content="noindex">
<title>Edit</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="format-detection" content="telephone=no">
<link rel="stylesheet" href="web/codemirror/lib/codemirror.css">
<link rel="stylesheet" href="web/codemirror/theme/idea.css">
<script src="web/codemirror/lib/codemirror.js"></script>
<script src="web/codemirror/addon/mode/simple.js"></script>
<script src="web/codemirror/addon/selection/active-line.js"></script>
<script src="web/codemirror/addon/edit/trailingspace.js"></script>
<script src="web/codemirror/addon/display/placeholder.js"></script>
<script src="web/codemirror_mode_loda.js"></script>
<link media="all" rel="stylesheet" type="text/css" href="web/loda_rust_web.css">
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>


<script>
// Construct url for a program id (eg A112088), like the following
// https://raw.githubusercontent.com/loda-lang/loda-programs/main/oeis/112/A112088.asm
function urlFromProgramId(programId) {
  const zeroPad = (num, places) => String(num).padStart(places, '0');
  const dir_index_string = zeroPad(Math.floor(programId/1000), 3);
  const filename_string = "A" + zeroPad(programId, 6) + ".asm";
  let baseurl = "https://raw.githubusercontent.com/loda-lang/loda-programs/main/oeis";
  let url = `${baseurl}/${dir_index_string}/${filename_string}`;
  return url;
}

class PageController {
  constructor(dict) {
    console.log("PageController.ctor");

    // Install `runSourceCode` callback
    this.runSourceCode = dict['runSourceCode'] || function(sourceCode, termCount, runId) {
      console.error("PageController.runSourceCode() callback not installed");
    };

    this.mTick = 0;
    this.mUpdateTick = false;
    this.mRunId = 0;
    this.mIdenticalToOriginal = true;
    this.mOriginalText = "";
    this.mEditor = this.configureEditor();
    this.mOutputChart = this.configureChart();
    this.configureKeyboardShortcuts();
    this.configureOutputCount();
    this.prepareProgram();
    this.rebuildChart();
    this.mWorker = this.configureWorker();
  }

  configureWorker() {
    const worker = new Worker('worker.js', { type: 'module' });
    // const worker = new Worker('worker.js');
    worker.addEventListener('message', (e) => {
      this.workerOnMessage(e);
    }, false);
    worker.addEventListener('error', (e) => {
      this.workerOnError(e);
    }, false);
    // worker.postMessage({
    //   fn: "setup"
    // });
    // worker.postMessage({
    //   fn: "range", 
    //   rangeStart: 0,
    //   rangeLength: 10
    // });
    return worker;
  }

  workerOnError(e) {
    const errorMessage = [
      'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message
    ].join('');
    this.outputArea_appendError(errorMessage);
  }
  
  workerOnMessage(e) {
    switch (e.data.fn) {
    case "result":
      this.commandResult(e.data);
      break;
    case "debug":
      this.commandDebug(e.data);
      break;
    default:
      console.error(`workerOnMessage.unknown: ${e.data}`);
      this.outputArea_appendError("unknown message, see log");
      break;
    }
  }

  commandResult(parameters) {
    // console.log("worker result", parameters.value);
    this.outputArea_appendTerm(parameters.value);
  }

  commandDebug(parameters) {
    console.log("worker debug", parameters);
  }

  outputArea_appendTerm(termValue) {
    const div = document.getElementById("output-inner2");

    const a0 = document.createElement("span");
    a0.className = "separator";
    const a1 = document.createTextNode(",");
    a0.appendChild(a1);

    const b0 = document.createElement("span");
    b0.className = "term";
    const b1 = document.createTextNode(`${termValue}`);
    b0.appendChild(b1);

    div.appendChild(a0);
    div.appendChild(b0);
  }

  outputArea_appendError(message) {
    const div = document.getElementById("output-inner2");

    const a0 = document.createElement("span");
    a0.className = "separator";
    const a1 = document.createTextNode(",");
    a0.appendChild(a1);

    const b0 = document.createElement("span");
    b0.className = "error";
    const b1 = document.createTextNode(message);
    b0.appendChild(b1);

    div.appendChild(a0);
    div.appendChild(b0);
  }

  configureEditor() {
    const editor = CodeMirror.fromTextArea(document.getElementById("editor-inner"), {
      lineNumbers: true,
      lineWrapping: false,
      styleActiveLine: true,
      theme: "idea",
      mode: "loda",
      showTrailingSpace: true,
      tabSize: 2,
      indentWithTabs: false,
    });
    return editor;
  }

  configureChart() {
    var chart_config = {
      type: 'scatter',
      data: {
          datasets: []
      },
      options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          tooltips: {
              mode: 'point',
              callbacks: {
                  label: function(tooltipItem, data) {
                      var pointItem = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                      var s = pointItem.label;
                      var is_string = (typeof s == 'string') || (s instanceof String);
                      if (is_string) {
                          return s;
                      } else {
                          return "x: " + pointItem.x + " y: " + pointItem.y;
                      }
                  }
              },
          },
          legend: {
              display: false,
          }
        }
    };

    var ctx = document.getElementById('output-chart').getContext('2d');
    return new Chart(ctx, chart_config);
  }

  hideOverlay() {
    document.getElementById("overlay").style.display = "none";
  }

  showOverlay() {
    document.getElementById("overlay").style.display = "block";
  }

  getNumberOfTerms() {
    var radios = document.getElementsByName("outputcountname");
    const length = radios.length;
    var value = 10;
    for (var i = 0; i < length; i++) {
      if (radios[i].checked) {
        value = radios[i].value;
        break;
      }
    }
    return value;
  }

  configureOutputCount() {
    const el = document.getElementById('output-count');
    var self = this;
    el.addEventListener('change', function(e) {
      self.runAction();
    }, false);
  }

  prepareProgram() {
    let params = new URLSearchParams(window.location.search);
    if (params.has('source')) {
      let sourceCode = params.get('source');
      this.prepareProgramSourceCode(sourceCode);
      return;
    }
    if (params.has('oeis')) {
      var programId = params.get('oeis');
      programId = programId.replace(/^A0*/i, '');
      this.prepareProgramId(programId);
      return;
    }
    console.log("Missing or unrecognized url parameters. Showing an empty program.");
    this.prepareProgramEmpty();
  }

  prepareProgramEmpty() {
    const sourceCode = "";
    this.mIdenticalToOriginal = true;
    this.mOriginalText = sourceCode;
    this.mEditor.setValue(sourceCode);
    this.mEditor.focus();
    this.hideOverlay();
    var self = this;
    setTimeout(function() { self.didLoadProgram(); }, 100);
  }

  prepareProgramSourceCode(sourceCode) {
    console.log("prepareProgramSourceCode", sourceCode);
    this.mIdenticalToOriginal = true;
    this.mOriginalText = sourceCode;
    this.mEditor.setValue(sourceCode);
    this.mEditor.focus();
    this.hideOverlay();
    var self = this;
    setTimeout(function() { self.didLoadProgram(); }, 100);
  }

  prepareProgramId(programId) {
    console.log("prepareProgramId", programId);

    let url = urlFromProgramId(programId);

    var output = document.getElementById("output-inner");
    output.innerText = 'Downloading';

    // TODO: deal with status code when there is no 404 and show error message
    fetch(url)
      .then(response => response.text())
      .then(textdata => {
        console.log('Did fetch program');
        this.mIdenticalToOriginal = true;
        this.mOriginalText = textdata;
        this.mEditor.setValue(textdata);
        this.mEditor.focus();
        this.hideOverlay();

        var self = this;
        setTimeout(function() { self.didLoadProgram(); }, 100);
      })
      .catch((error) => {
        console.error('Error:', error);
        const textdata = "Unable to load program!";
        this.mIdenticalToOriginal = true;
        this.mOriginalText = textdata;
        this.mEditor.setValue(textdata);
        this.mEditor.focus();
        this.hideOverlay();
      });
  }

  didLoadProgram() {
    console.log("didLoadProgram");
    var output = document.getElementById("output-inner");
    output.innerText = 'Computing';
    this.runAction();
  }

  outputInnerAppendErrorMessage(message) {
    var output = document.getElementById("output-inner");
    var el0 = document.createElement('span');
    el0.className = "separator";
    el0.innerText = ",";
    output.appendChild(el0);
    var el1 = document.createElement('span');
    el1.className = "error";
    el1.innerText = message;
    output.appendChild(el1);
  }

  executeTick() {
    if (!this.mUpdateTick) {
      return;
    }
    // console.log(`tick: ${this.mTick}`);
    if (this.mTick >= 100) {
      this.mUpdateTick = false;
      this.outputInnerAppendErrorMessage("Stopped - exceeded 10 second time limit.");
      return;
    }
    this.mTick += 1;
    var self = this;
    setTimeout(function() { self.executeTick(); }, 100);
  }

  configureKeyboardShortcuts() {
    let pageControllerInstance = this;
    let keydownHandler = function(event) {
      if(event.defaultPrevented) {
        return; // Should do nothing if the default action has been cancelled
      }
      const isMetaKey = event.metaKey || event.ctrlKey;
      const isEnterKeyCode = (event.keyCode == 10) || (event.keyCode == 13);
      const isEscapeKeyCode = (event.keyCode == 27);
      // intercept CTRL+ENTER, and run the program.
      if(isEnterKeyCode && isMetaKey) {
        console.log("ctrl+enter: submit form");
        event.preventDefault(); // Suppress "double action"
        pageControllerInstance.runAction();
        return;
      }
      // intercept ESCape key, and stop a running program.
      if(isEscapeKeyCode) {
        console.log("escape: stop running");
        event.preventDefault(); // Suppress "double action"
        pageControllerInstance.stopAction();
        return;
      }
    };
    window.addEventListener('keydown', keydownHandler, true);
  }

  runAction() {
    this.mTick = 0;
    this.mUpdateTick = true;
    this.mRunId = (this.mRunId + 1) % 256;
    const runIdClone0 = this.mRunId * 10;
    const runIdClone1 = runIdClone0 / 10;
    this.executeTick();
    let sourceCode = this.mEditor.getValue();
    let termCount = this.getNumberOfTerms();
    this.runSourceCode(sourceCode, termCount, runIdClone1);
  }

  stopAction() {
    console.log("Stop button");
    this.mUpdateTick = false;
  }

  showInfo() {
    console.log("Show info");
    window.open(
      "https://loda-lang.org/",
      '_blank' // Open in a new window.
    );
  }

  isRunningProgram(runId) {
    if (!this.mUpdateTick) {
      return false;
    }
    if (this.mRunId != runId) {
      return false;
    }
    return true;
  }

  finishedComputingTheLastTerm() {
    console.log("finished computing the last term");
    this.mUpdateTick = false;
    this.rebuildChart();
  }

  exceptionOccurredWhileRunning(message) {
    this.mUpdateTick = false;
    this.outputInnerAppendErrorMessage(message);
  }

  programURLString() {
    let sourceCode = this.mEditor.getValue();
    var url = new URL(window.location.href);
    url.search = `source=${encodeURIComponent(sourceCode)}`;
    return url.href;
  }

  copyProgramURLToClipboard() {
    let urlString = this.programURLString();
    navigator.clipboard.writeText(urlString);
    let byteCount = urlString.length;
    let tooltip = document.getElementById("copy-program-link-to-clipboard-tooltip-text");
    tooltip.innerHTML = `Copied ${byteCount} bytes to clipboard`;
  }

  hideCopyToClipboardTooltip() {
    let tooltip = document.getElementById("copy-program-link-to-clipboard-tooltip-text");
    tooltip.innerHTML = "Copy to clipboard";
  }

  rebuildChart() {
      var chart = this.mOutputChart;
      
      var count = 100;
      var dataAll = [];
      // for ( var i = 0; i < count; i+=1 ) {
      //     const value = i;
      //     const y = Math.floor(value);
      //     const dict = {
      //         x: i,
      //         y: y,
      //         label: `a(${i}) = ${y}`
      //     };
      //     dataAll.push(dict);
      // }

      const div = document.getElementById("output-inner");
      const text = div.innerText;
      console.log("text", text);
      const textItems = text.split(",");
      for (var i = 0; i < textItems.length; i += 1) {
        const textItem = textItems[i];
        var value = parseInt(textItem);
        if (isNaN(value)) { 
          value = 0;
        }
        const y = Math.floor(value);
          const dict = {
              x: i,
              y: y,
              label: `a(${i}) = ${y}`
          };
          dataAll.push(dict);
      }
      
      const datasetAll = {
          label: 'All',
          backgroundColor: 'rgba(25,25,25,1.0)',
          pointRadius: 1,
          pointHitRadius: 5,
          borderWidth: 0,
          data: dataAll,
      };
      
      while (chart.data.datasets.length > 0) {
          chart.data.datasets.pop();
      }
      chart.data.datasets.push(datasetAll);
      
      chart.update();
  }
}

var gPageController = null;

var callbackExecuteSourceCode = (sourceCode, termCount, runId) => {
  console.log("callbackExecuteSourceCode is not installed");
}
var callbackFinishedWasmLoading = () => {
  console.log("callbackFinishedWasmLoading invoked");
}

function body_onload() {
  const runSourceCode = function(sourceCode, termCount, runId) {
    callbackExecuteSourceCode(sourceCode, termCount, runId);
  };
  const dict = {
    'runSourceCode': runSourceCode
  };
  gPageController = new PageController(dict);
}

function body_onbeforeunload() {
  if (gPageController.mIdenticalToOriginal) {
    return undefined;
  } else {
    return "The data on this page will be lost if you leave";
  }
}
</script>
<!-- <script type="module" src="index.js"></script> -->

</head>

<body onload="body_onload()" onbeforeunload="return body_onbeforeunload()">

<div id="overlay">
  <div id="overlay-message">Initializing&hellip;</div>
</div>

<header class="top-banner-container-outer" id="top-banner">
  <div class="top-banner-container-inner">
    <div class="top-banner-item top-banner-item-left">
      &#9888;
    </div>
    <div class="top-banner-item top-banner-item-center">
      There was a problem sending the data. Please try again.<br>
      <span id="top-banner-item-center-content">No details available.</span>
    </div>
    <div class="top-banner-item top-banner-item-right">
      &#9888;
    </div>
  </div>
</header>
  
<header class="titlebar-container">
  <div class="titlebar-item titlebar-item-left">
    <button class="seconday-button" onclick="gPageController.showInfo()">LODA Language</button>
  </div>

  <div class="titlebar-item titlebar-item-center">Edit</div>

  <div class="titlebar-item titlebar-item-right">
    <button class="seconday-button" onclick="gPageController.stopAction()">Stop (Esc)</button>
    <button id="run-button" class="primary-button" onclick="gPageController.runAction()">Run (Ctrl+Enter)</button>
  </div>
</header>

<main id="splitview-outer">
  <div id="splitview-inner">

    <div id="editor-outer">
      <textarea id="editor-inner" placeholder="Content goes here&hellip;"> </textarea>
    </div>

    <div id="output-outer">

      <div id="output-count">
        Number of terms:
        <span class="output-count-radio-item">
          <input type="radio" id="count10" name="outputcountname" value="10" checked="on">
          <label for="count10">10</label>
        </span>
        <span class="output-count-radio-item">
          <input type="radio" id="count100" name="outputcountname" value="100">
          <label for="count100">100</label>
        </span>
        <span class="output-count-radio-item">
          <input type="radio" id="count1000" name="outputcountname" value="1000">
          <label for="count1000">1000</label>
        </span>      
      </div>

      <div class="chart-container" style="position: relative;height:40vh">
        <canvas id="output-chart"></canvas>
      </div>

      <div id="output-inner">
        Output Area
      </div>
      <div id="output-inner2">
        Output Area
      </div>
    </div>

  </div>
</main>

<footer id="page-footer">
  <div id="page-footer-item0" class="page-footer-item">
    Link to this program
    <div class="copy-program-link-to-clipboard-tooltip-area">
      <button onclick="gPageController.copyProgramURLToClipboard()" onmouseout="gPageController.hideCopyToClipboardTooltip()">
        <span class="tooltiptext" id="copy-program-link-to-clipboard-tooltip-text">Copy to clipboard</span>
        Copy
      </button>
    </div>
  </div>
  <div id="page-footer-item1" class="page-footer-item">
    Updated: 2021 Dec 1<br>
    Source code: <a target="_blank" href="https://github.com/loda-lang/loda-rust">https://github.com/loda-lang/loda-rust</a>
  </div>
</footer>

</body>
</html>